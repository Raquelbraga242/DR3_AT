A arquitetura escolhida para o projeto PetFriends utiliza um modelo totalmente reativo, baseado em Spring WebFlux, porque esse estilo é mais eficiente para aplicações distribuídas compostas por múltiplos microserviços que se comunicam constantemente entre si. Em um cenário com muitas requisições simultâneas e dependência de chamadas externas (como consultas entre serviços ou acesso ao banco), a abordagem reativa evita bloqueios, reduz consumo de threads e melhora a escalabilidade. Assim, a aplicação lida melhor com grandes volumes de chamadas e permanece responsiva.
A decisão de usar Kubernetes, especificamente via Minikube, foi feita porque esse é o padrão moderno para orquestração de microserviços. Minikube permite simular em ambiente local um cluster real de produção, oferecendo testes práticos de escalabilidade, replicação, comunicação interna entre serviços e tolerância a falhas. Além disso, é leve, simples de instalar e ideal para desenvolvimento, sem depender de uma nuvem real ou de infraestrutura complexa. Isso garante que a arquitetura projetada seja realista e aplicável no mercado.
Para persistência de dados, o projeto utiliza MongoDB, um banco orientado a documentos que combina bem com a estrutura das entidades do sistema (como cliente, pedido e produto) que são naturalmente flexíveis e não exigem relacionamentos complexos. O MongoDB é totalmente compatível com o ecossistema reativo do Spring, permitindo operações assíncronas e não bloqueantes, o que mantém a coerência com o restante da arquitetura. Além disso, ele simplifica o armazenamento de listas como o histórico de pedidos dentro dos dados do cliente.
A divisão das responsabilidades entre os microserviços também foi cuidadosamente planejada. O cliente-service é o único serviço conectado ao banco de dados porque ele representa os dados mais estáveis e importantes do domínio: as informações dos clientes e seu histórico de compras. Centralizar a persistência nele evita acoplamento desnecessário, elimina a necessidade de transações distribuídas e segue o princípio de que cada microserviço deve ser dono de seus próprios dados. O estoque-service, por sua vez, é responsável apenas por fornecer informações de produtos e quantidades disponíveis, servindo como um provedor simples e independente. Já o pedido-service coordena o fluxo: ele  consulta o estoque-service para validar disponibilidade, gera automaticamente o ID do pedido e envia os dados em seguida para o cliente-service, que registra esse pedido no histórico do cliente. 
Em conjunto, todas as escolhas (uso de reatividade, Minikube, MongoDB e divisão funcional dos microserviços) foram tomadas para garantir eficiência, escalabilidade, baixo acoplamento e simplicidade operacional. A arquitetura final é coerente, realista, alinhada com boas práticas do mercado e cumpre integralmente as exigências do enunciado.
